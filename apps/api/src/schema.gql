# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AuthResponse {
  accessToken: String
  expiresIn: Float
  isNewUser: Boolean
  refreshToken: String
  user: User!
}

type Book {
  _count: BookCount!
  authors: [String!]
  covers: [Cover!]
  id: ID!
  identifiers: [Identifier!]
  pageCount: Int
  ratings: [Rating!]
  slug: String!
  subtitle: String
  title: String!
  userBook: UserBook
  yearPublished: String
}

type BookAvgAggregate {
  pageCount: Float
}

type BookCount {
  covers: Int!
  identifiers: Int!
  ratings: Int!
}

type BookCountAggregate {
  _all: Int!
  authors: Int!
  id: Int!
  pageCount: Int!
  slug: Int!
  subtitle: Int!
  title: Int!
  yearPublished: Int!
}

type BookCountsResponse {
  finishedCount: Float!
  readingCount: Float!
  upNextCount: Float!
  wantsToReadCount: Float!
}

input BookCreateNestedOneWithoutCoversInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutCoversInput
  create: BookCreateWithoutCoversInput
}

input BookCreateNestedOneWithoutIdentifiersInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutIdentifiersInput
  create: BookCreateWithoutIdentifiersInput
}

input BookCreateNestedOneWithoutRatingsInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutRatingsInput
  create: BookCreateWithoutRatingsInput
}

input BookCreateNestedOneWithoutUserBookInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUserBookInput
  create: BookCreateWithoutUserBookInput
}

input BookCreateOrConnectWithoutCoversInput {
  create: BookCreateWithoutCoversInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutIdentifiersInput {
  create: BookCreateWithoutIdentifiersInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutRatingsInput {
  create: BookCreateWithoutRatingsInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutUserBookInput {
  create: BookCreateWithoutUserBookInput!
  where: BookWhereUniqueInput!
}

input BookCreateWithoutCoversInput {
  authors: [String!]
  id: String
  identifiers: IdentifierCreateNestedManyWithoutBookInput
  pageCount: Int
  ratings: RatingCreateNestedManyWithoutBookInput
  slug: String!
  subtitle: String
  title: String!
  userBook: UserBookCreateNestedOneWithoutBookInput
  yearPublished: String
}

input BookCreateWithoutIdentifiersInput {
  authors: [String!]
  covers: CoverCreateNestedManyWithoutBookInput
  id: String
  pageCount: Int
  ratings: RatingCreateNestedManyWithoutBookInput
  slug: String!
  subtitle: String
  title: String!
  userBook: UserBookCreateNestedOneWithoutBookInput
  yearPublished: String
}

input BookCreateWithoutRatingsInput {
  authors: [String!]
  covers: CoverCreateNestedManyWithoutBookInput
  id: String
  identifiers: IdentifierCreateNestedManyWithoutBookInput
  pageCount: Int
  slug: String!
  subtitle: String
  title: String!
  userBook: UserBookCreateNestedOneWithoutBookInput
  yearPublished: String
}

input BookCreateWithoutUserBookInput {
  authors: [String!]
  covers: CoverCreateNestedManyWithoutBookInput
  id: String
  identifiers: IdentifierCreateNestedManyWithoutBookInput
  pageCount: Int
  ratings: RatingCreateNestedManyWithoutBookInput
  slug: String!
  subtitle: String
  title: String!
  yearPublished: String
}

input BookDataInput {
  authors: [String!]!
  covers: [CoverCreateInput!]!
  identifiers: [IdentifierCreateInput!]!
  pageCount: Float!
  ratings: [RatingCreateInput!]!
  slug: String
  subtitle: String
  title: String!
  yearPublished: String
}

type BookMaxAggregate {
  id: String
  pageCount: Int
  slug: String
  subtitle: String
  title: String
  yearPublished: String
}

type BookMinAggregate {
  id: String
  pageCount: Int
  slug: String
  subtitle: String
  title: String
  yearPublished: String
}

input BookOrderByWithRelationInput {
  authors: SortOrder
  covers: CoverOrderByRelationAggregateInput
  id: SortOrder
  identifiers: IdentifierOrderByRelationAggregateInput
  pageCount: SortOrderInput
  ratings: RatingOrderByRelationAggregateInput
  slug: SortOrder
  subtitle: SortOrderInput
  title: SortOrder
  userBook: UserBookOrderByWithRelationInput
  yearPublished: SortOrderInput
}

input BookScalarRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

type BookSumAggregate {
  pageCount: Int
}

input BookUpdateOneRequiredWithoutUserBookNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutUserBookInput
  create: BookCreateWithoutUserBookInput
  update: BookUpdateToOneWithWhereWithoutUserBookInput
  upsert: BookUpsertWithoutUserBookInput
}

input BookUpdateToOneWithWhereWithoutUserBookInput {
  data: BookUpdateWithoutUserBookInput!
  where: BookWhereInput
}

input BookUpdateWithoutUserBookInput {
  authors: [String!]
  covers: CoverUpdateManyWithoutBookNestedInput
  id: String
  identifiers: IdentifierUpdateManyWithoutBookNestedInput
  pageCount: Int
  ratings: RatingUpdateManyWithoutBookNestedInput
  slug: String
  subtitle: String
  title: String
  yearPublished: String
}

input BookUpsertWithoutUserBookInput {
  create: BookCreateWithoutUserBookInput!
  update: BookUpdateWithoutUserBookInput!
  where: BookWhereInput
}

input BookWhereInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  authors: StringListFilter
  covers: CoverListRelationFilter
  id: StringFilter
  identifiers: IdentifierListRelationFilter
  pageCount: IntFilter
  ratings: RatingListRelationFilter
  slug: StringFilter
  subtitle: StringFilter
  title: StringFilter
  userBook: UserBookScalarRelationFilter
  yearPublished: StringFilter
}

input BookWhereUniqueInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  authors: StringListFilter
  covers: CoverListRelationFilter
  id: String
  identifiers: IdentifierListRelationFilter
  pageCount: IntFilter
  ratings: RatingListRelationFilter
  slug: String
  subtitle: StringFilter
  title: StringFilter
  userBook: UserBookScalarRelationFilter
  yearPublished: StringFilter
}

input BoolFilter {
  equals: Boolean
  not: BoolFilter
}

type Cover {
  book: Book
  bookId: String
  id: ID!
  size: SIZE!
  source: SOURCE!
  url: String!
}

type CoverCountAggregate {
  _all: Int!
  bookId: Int!
  id: Int!
  size: Int!
  source: Int!
  url: Int!
}

input CoverCreateInput {
  book: BookCreateNestedOneWithoutCoversInput
  id: String
  size: SIZE!
  source: SOURCE!
  url: String!
}

input CoverCreateManyBookInput {
  id: String
  size: SIZE!
  source: SOURCE!
  url: String!
}

input CoverCreateManyBookInputEnvelope {
  data: [CoverCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input CoverCreateNestedManyWithoutBookInput {
  connect: [CoverWhereUniqueInput!]
  connectOrCreate: [CoverCreateOrConnectWithoutBookInput!]
  create: [CoverCreateWithoutBookInput!]
  createMany: CoverCreateManyBookInputEnvelope
}

input CoverCreateOrConnectWithoutBookInput {
  create: CoverCreateWithoutBookInput!
  where: CoverWhereUniqueInput!
}

input CoverCreateWithoutBookInput {
  id: String
  size: SIZE!
  source: SOURCE!
  url: String!
}

input CoverListRelationFilter {
  every: CoverWhereInput
  none: CoverWhereInput
  some: CoverWhereInput
}

type CoverMaxAggregate {
  bookId: String
  id: String
  size: SIZE
  source: SOURCE
  url: String
}

type CoverMinAggregate {
  bookId: String
  id: String
  size: SIZE
  source: SOURCE
  url: String
}

input CoverOrderByRelationAggregateInput {
  _count: SortOrder
}

input CoverScalarWhereInput {
  AND: [CoverScalarWhereInput!]
  NOT: [CoverScalarWhereInput!]
  OR: [CoverScalarWhereInput!]
  bookId: StringFilter
  id: StringFilter
  size: EnumSIZEFilter
  source: EnumSOURCEFilter
  url: StringFilter
}

input CoverUpdateManyMutationInput {
  id: String
  size: SIZE
  source: SOURCE
  url: String
}

input CoverUpdateManyWithWhereWithoutBookInput {
  data: CoverUpdateManyMutationInput!
  where: CoverScalarWhereInput!
}

input CoverUpdateManyWithoutBookNestedInput {
  connect: [CoverWhereUniqueInput!]
  connectOrCreate: [CoverCreateOrConnectWithoutBookInput!]
  create: [CoverCreateWithoutBookInput!]
  createMany: CoverCreateManyBookInputEnvelope
  delete: [CoverWhereUniqueInput!]
  deleteMany: [CoverScalarWhereInput!]
  disconnect: [CoverWhereUniqueInput!]
  set: [CoverWhereUniqueInput!]
  update: [CoverUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [CoverUpdateManyWithWhereWithoutBookInput!]
  upsert: [CoverUpsertWithWhereUniqueWithoutBookInput!]
}

input CoverUpdateWithWhereUniqueWithoutBookInput {
  data: CoverUpdateWithoutBookInput!
  where: CoverWhereUniqueInput!
}

input CoverUpdateWithoutBookInput {
  id: String
  size: SIZE
  source: SOURCE
  url: String
}

input CoverUpsertWithWhereUniqueWithoutBookInput {
  create: CoverCreateWithoutBookInput!
  update: CoverUpdateWithoutBookInput!
  where: CoverWhereUniqueInput!
}

input CoverWhereInput {
  AND: [CoverWhereInput!]
  NOT: [CoverWhereInput!]
  OR: [CoverWhereInput!]
  book: BookScalarRelationFilter
  bookId: StringFilter
  id: StringFilter
  size: EnumSIZEFilter
  source: EnumSOURCEFilter
  url: StringFilter
}

input CoverWhereUniqueInput {
  AND: [CoverWhereInput!]
  NOT: [CoverWhereInput!]
  OR: [CoverWhereInput!]
  book: BookScalarRelationFilter
  bookId: StringFilter
  id: String
  size: EnumSIZEFilter
  source: EnumSOURCEFilter
  url: String
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: DateTimeFilter
  notIn: [Timestamp!]
}

input EnumPROGRESS_TYPEFilter {
  equals: PROGRESS_TYPE
  in: [PROGRESS_TYPE!]
  not: EnumPROGRESS_TYPEFilter
  notIn: [PROGRESS_TYPE!]
}

input EnumREADING_STATUSFilter {
  equals: READING_STATUS
  in: [READING_STATUS!]
  not: EnumREADING_STATUSFilter
  notIn: [READING_STATUS!]
}

input EnumSIZEFilter {
  equals: SIZE
  in: [SIZE!]
  not: EnumSIZEFilter
  notIn: [SIZE!]
}

input EnumSOURCEFilter {
  equals: SOURCE
  in: [SOURCE!]
  not: EnumSOURCEFilter
  notIn: [SOURCE!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: FloatFilter
  notIn: [Float!]
}

type HealthCheck {
  message: String!
  status: String!
  timestamp: String!
}

type Identifier {
  book: Book
  bookId: String
  id: ID!
  source: SOURCE!
  sourceId: String!
}

type IdentifierCountAggregate {
  _all: Int!
  bookId: Int!
  id: Int!
  source: Int!
  sourceId: Int!
}

input IdentifierCreateInput {
  book: BookCreateNestedOneWithoutIdentifiersInput
  id: String
  source: SOURCE!
  sourceId: String!
}

input IdentifierCreateManyBookInput {
  id: String
  source: SOURCE!
  sourceId: String!
}

input IdentifierCreateManyBookInputEnvelope {
  data: [IdentifierCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input IdentifierCreateNestedManyWithoutBookInput {
  connect: [IdentifierWhereUniqueInput!]
  connectOrCreate: [IdentifierCreateOrConnectWithoutBookInput!]
  create: [IdentifierCreateWithoutBookInput!]
  createMany: IdentifierCreateManyBookInputEnvelope
}

input IdentifierCreateOrConnectWithoutBookInput {
  create: IdentifierCreateWithoutBookInput!
  where: IdentifierWhereUniqueInput!
}

input IdentifierCreateWithoutBookInput {
  id: String
  source: SOURCE!
  sourceId: String!
}

input IdentifierListRelationFilter {
  every: IdentifierWhereInput
  none: IdentifierWhereInput
  some: IdentifierWhereInput
}

type IdentifierMaxAggregate {
  bookId: String
  id: String
  source: SOURCE
  sourceId: String
}

type IdentifierMinAggregate {
  bookId: String
  id: String
  source: SOURCE
  sourceId: String
}

input IdentifierOrderByRelationAggregateInput {
  _count: SortOrder
}

input IdentifierScalarWhereInput {
  AND: [IdentifierScalarWhereInput!]
  NOT: [IdentifierScalarWhereInput!]
  OR: [IdentifierScalarWhereInput!]
  bookId: StringFilter
  id: StringFilter
  source: EnumSOURCEFilter
  sourceId: StringFilter
}

input IdentifierUpdateManyMutationInput {
  id: String
  source: SOURCE
  sourceId: String
}

input IdentifierUpdateManyWithWhereWithoutBookInput {
  data: IdentifierUpdateManyMutationInput!
  where: IdentifierScalarWhereInput!
}

input IdentifierUpdateManyWithoutBookNestedInput {
  connect: [IdentifierWhereUniqueInput!]
  connectOrCreate: [IdentifierCreateOrConnectWithoutBookInput!]
  create: [IdentifierCreateWithoutBookInput!]
  createMany: IdentifierCreateManyBookInputEnvelope
  delete: [IdentifierWhereUniqueInput!]
  deleteMany: [IdentifierScalarWhereInput!]
  disconnect: [IdentifierWhereUniqueInput!]
  set: [IdentifierWhereUniqueInput!]
  update: [IdentifierUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [IdentifierUpdateManyWithWhereWithoutBookInput!]
  upsert: [IdentifierUpsertWithWhereUniqueWithoutBookInput!]
}

input IdentifierUpdateWithWhereUniqueWithoutBookInput {
  data: IdentifierUpdateWithoutBookInput!
  where: IdentifierWhereUniqueInput!
}

input IdentifierUpdateWithoutBookInput {
  id: String
  source: SOURCE
  sourceId: String
}

input IdentifierUpsertWithWhereUniqueWithoutBookInput {
  create: IdentifierCreateWithoutBookInput!
  update: IdentifierUpdateWithoutBookInput!
  where: IdentifierWhereUniqueInput!
}

input IdentifierWhereInput {
  AND: [IdentifierWhereInput!]
  NOT: [IdentifierWhereInput!]
  OR: [IdentifierWhereInput!]
  book: BookScalarRelationFilter
  bookId: StringFilter
  id: StringFilter
  source: EnumSOURCEFilter
  sourceId: StringFilter
}

input IdentifierWhereUniqueInput {
  AND: [IdentifierWhereInput!]
  NOT: [IdentifierWhereInput!]
  OR: [IdentifierWhereInput!]
  book: BookScalarRelationFilter
  bookId: StringFilter
  id: String
  source: EnumSOURCEFilter
  sourceId: StringFilter
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: IntFilter
  notIn: [Int!]
}

input LogInInput {
  email: String!
  password: String
}

type Mutation {
  addBookToShelf(shelf: String!, where: UserBookWhereUniqueInput!): UserBook!
  addIdentifierToBook(identifier: IdentifierCreateInput!, where: BookWhereUniqueInput!): Book!
  createIdentifiers(identifiers: [IdentifierCreateInput!]!): [Identifier!]!
  createShelf(data: ShelfCreateInput!): Shelf!
  createUserBook(data: BookDataInput!): UserBook!
  deleteShelf(where: ShelfWhereUniqueInput!): Shelf!
  forgotPassword(email: String!): Boolean!
  importUserBooks(content: String!, favoritesShelf: String, ownedShelf: String, shelves: [String!]): Boolean!
  login(logInInput: LogInInput!): AuthResponse!
  logout(id: String!): Boolean!
  refreshAuth: RefreshResponse!
  register(registerInput: RegisterInput!): User!
  removeBookFromShelf(shelf: String!, where: UserBookWhereUniqueInput!): Boolean!
  removeUserBook(where: UserBookWhereUniqueInput!): Boolean!
  resetPassword(resetPasswordInput: ResetPasswordInput!): Boolean!
  sendEmailCode(email: String!): Boolean!
  updateEmail(data: UpdateEmailInput!): AuthResponse!
  updatePassword(data: UpdatePasswordInput!): User!
  updateReadDate(finishedDate: String, id: String!, startDate: String): ReadDate!
  updateReadingProgress(capacity: Int, progress: Int!, readingProgressId: String!, type: String!): ReadingProgress!
  updateShelf(data: ShelfUpdateInput!, where: ShelfWhereUniqueInput!): Shelf!
  updateUser(data: UpdateUserInput!): User!
  updateUserBook(data: UserBookUpdateInput!, where: UserBookWhereUniqueInput!): UserBook!
}

enum NullsOrder {
  first
  last
}

enum PROGRESS_TYPE {
  PAGES
  PERCENTAGE
}

type PasswordResetTokenCountAggregate {
  _all: Int!
  email: Int!
  expires: Int!
  id: Int!
  token: Int!
}

type PasswordResetTokenMaxAggregate {
  email: String
  expires: Timestamp
  id: String
  token: String
}

type PasswordResetTokenMinAggregate {
  email: String
  expires: Timestamp
  id: String
  token: String
}

type Query {
  book(where: BookWhereUniqueInput!): Book
  bookCountsByUserId(userId: String!): BookCountsResponse!
  booksByShelf(slug: String!, username: String!): Shelf
  countUserBooks(where: UserBookWhereInput): Int!
  findBookByIdentifier(identifier: IdentifierCreateInput!): Book
  getBookByIdentifiers(identifiers: [IdentifierCreateInput!]!): [Identifier!]!
  getMyBookShelves(where: UserBookWhereUniqueInput): [UserBookShelves!]
  getUserBooks(limit: Int! = 20, offset: Int! = 0, orderBy: UserBookOrderByWithRelationInput, where: UserBookWhereInput): UserBooksResponse!
  healthCheck: HealthCheck!
  readDates(active: Boolean, userBookIds: [String!]!): [ReadDate!]!
  searchMyLibrary(query: String!): [Book!]!
  shelves: [Shelf!]
  user(where: UserWhereUniqueInput!): User
  userBook(where: BookWhereUniqueInput!): UserBook
  userLibraryGoogleIds: [String!]!
}

enum QueryMode {
  default
  insensitive
}

enum READING_STATUS {
  DID_NOT_FINISH
  FINISHED
  READING
  UP_NEXT
  WANT_TO_READ
}

type Rating {
  book: Book
  bookId: String
  count: Int
  id: ID!
  maxScore: Float!
  score: Float!
  source: SOURCE!
}

type RatingAvgAggregate {
  count: Float
  maxScore: Float
  score: Float
}

type RatingCountAggregate {
  _all: Int!
  bookId: Int!
  count: Int!
  id: Int!
  maxScore: Int!
  score: Int!
  source: Int!
}

input RatingCreateInput {
  book: BookCreateNestedOneWithoutRatingsInput
  count: Int
  id: String
  maxScore: Float!
  score: Float!
  source: SOURCE!
}

input RatingCreateManyBookInput {
  count: Int
  id: String
  maxScore: Float!
  score: Float!
  source: SOURCE!
}

input RatingCreateManyBookInputEnvelope {
  data: [RatingCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input RatingCreateNestedManyWithoutBookInput {
  connect: [RatingWhereUniqueInput!]
  connectOrCreate: [RatingCreateOrConnectWithoutBookInput!]
  create: [RatingCreateWithoutBookInput!]
  createMany: RatingCreateManyBookInputEnvelope
}

input RatingCreateOrConnectWithoutBookInput {
  create: RatingCreateWithoutBookInput!
  where: RatingWhereUniqueInput!
}

input RatingCreateWithoutBookInput {
  count: Int
  id: String
  maxScore: Float!
  score: Float!
  source: SOURCE!
}

input RatingListRelationFilter {
  every: RatingWhereInput
  none: RatingWhereInput
  some: RatingWhereInput
}

type RatingMaxAggregate {
  bookId: String
  count: Int
  id: String
  maxScore: Float
  score: Float
  source: SOURCE
}

type RatingMinAggregate {
  bookId: String
  count: Int
  id: String
  maxScore: Float
  score: Float
  source: SOURCE
}

input RatingOrderByRelationAggregateInput {
  _count: SortOrder
}

input RatingScalarWhereInput {
  AND: [RatingScalarWhereInput!]
  NOT: [RatingScalarWhereInput!]
  OR: [RatingScalarWhereInput!]
  bookId: StringFilter
  count: IntFilter
  id: StringFilter
  maxScore: FloatFilter
  score: FloatFilter
  source: EnumSOURCEFilter
}

type RatingSumAggregate {
  count: Int
  maxScore: Float
  score: Float
}

input RatingUpdateManyMutationInput {
  count: Int
  id: String
  maxScore: Float
  score: Float
  source: SOURCE
}

input RatingUpdateManyWithWhereWithoutBookInput {
  data: RatingUpdateManyMutationInput!
  where: RatingScalarWhereInput!
}

input RatingUpdateManyWithoutBookNestedInput {
  connect: [RatingWhereUniqueInput!]
  connectOrCreate: [RatingCreateOrConnectWithoutBookInput!]
  create: [RatingCreateWithoutBookInput!]
  createMany: RatingCreateManyBookInputEnvelope
  delete: [RatingWhereUniqueInput!]
  deleteMany: [RatingScalarWhereInput!]
  disconnect: [RatingWhereUniqueInput!]
  set: [RatingWhereUniqueInput!]
  update: [RatingUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [RatingUpdateManyWithWhereWithoutBookInput!]
  upsert: [RatingUpsertWithWhereUniqueWithoutBookInput!]
}

input RatingUpdateWithWhereUniqueWithoutBookInput {
  data: RatingUpdateWithoutBookInput!
  where: RatingWhereUniqueInput!
}

input RatingUpdateWithoutBookInput {
  count: Int
  id: String
  maxScore: Float
  score: Float
  source: SOURCE
}

input RatingUpsertWithWhereUniqueWithoutBookInput {
  create: RatingCreateWithoutBookInput!
  update: RatingUpdateWithoutBookInput!
  where: RatingWhereUniqueInput!
}

input RatingWhereInput {
  AND: [RatingWhereInput!]
  NOT: [RatingWhereInput!]
  OR: [RatingWhereInput!]
  book: BookScalarRelationFilter
  bookId: StringFilter
  count: IntFilter
  id: StringFilter
  maxScore: FloatFilter
  score: FloatFilter
  source: EnumSOURCEFilter
}

input RatingWhereUniqueInput {
  AND: [RatingWhereInput!]
  NOT: [RatingWhereInput!]
  OR: [RatingWhereInput!]
  book: BookScalarRelationFilter
  bookId: StringFilter
  count: IntFilter
  id: String
  maxScore: FloatFilter
  score: FloatFilter
  source: EnumSOURCEFilter
}

type ReadDate {
  active: Boolean!
  finishedDate: Timestamp
  id: ID!
  readingProgress: ReadingProgress
  startDate: Timestamp!
  userBook: UserBook
  userBookId: String
}

type ReadDateCountAggregate {
  _all: Int!
  active: Int!
  finishedDate: Int!
  id: Int!
  startDate: Int!
  userBookId: Int!
}

input ReadDateCreateManyUserBookInput {
  active: Boolean!
  finishedDate: Timestamp
  id: String
  startDate: Timestamp
}

input ReadDateCreateManyUserBookInputEnvelope {
  data: [ReadDateCreateManyUserBookInput!]!
  skipDuplicates: Boolean
}

input ReadDateCreateNestedManyWithoutUserBookInput {
  connect: [ReadDateWhereUniqueInput!]
  connectOrCreate: [ReadDateCreateOrConnectWithoutUserBookInput!]
  create: [ReadDateCreateWithoutUserBookInput!]
  createMany: ReadDateCreateManyUserBookInputEnvelope
}

input ReadDateCreateOrConnectWithoutUserBookInput {
  create: ReadDateCreateWithoutUserBookInput!
  where: ReadDateWhereUniqueInput!
}

input ReadDateCreateWithoutUserBookInput {
  active: Boolean!
  finishedDate: Timestamp
  id: String
  readingProgress: ReadingProgressCreateNestedOneWithoutReadDateInput
  startDate: Timestamp
}

input ReadDateListRelationFilter {
  every: ReadDateWhereInput
  none: ReadDateWhereInput
  some: ReadDateWhereInput
}

type ReadDateMaxAggregate {
  active: Boolean
  finishedDate: Timestamp
  id: String
  startDate: Timestamp
  userBookId: String
}

type ReadDateMinAggregate {
  active: Boolean
  finishedDate: Timestamp
  id: String
  startDate: Timestamp
  userBookId: String
}

input ReadDateOrderByRelationAggregateInput {
  _count: SortOrder
}

input ReadDateScalarRelationFilter {
  is: ReadDateWhereInput
  isNot: ReadDateWhereInput
}

input ReadDateScalarWhereInput {
  AND: [ReadDateScalarWhereInput!]
  NOT: [ReadDateScalarWhereInput!]
  OR: [ReadDateScalarWhereInput!]
  active: BoolFilter
  finishedDate: DateTimeFilter
  id: StringFilter
  startDate: DateTimeFilter
  userBookId: StringFilter
}

input ReadDateUpdateManyMutationInput {
  active: Boolean
  finishedDate: Timestamp
  id: String
  startDate: Timestamp
}

input ReadDateUpdateManyWithWhereWithoutUserBookInput {
  data: ReadDateUpdateManyMutationInput!
  where: ReadDateScalarWhereInput!
}

input ReadDateUpdateManyWithoutUserBookNestedInput {
  connect: [ReadDateWhereUniqueInput!]
  connectOrCreate: [ReadDateCreateOrConnectWithoutUserBookInput!]
  create: [ReadDateCreateWithoutUserBookInput!]
  createMany: ReadDateCreateManyUserBookInputEnvelope
  delete: [ReadDateWhereUniqueInput!]
  deleteMany: [ReadDateScalarWhereInput!]
  disconnect: [ReadDateWhereUniqueInput!]
  set: [ReadDateWhereUniqueInput!]
  update: [ReadDateUpdateWithWhereUniqueWithoutUserBookInput!]
  updateMany: [ReadDateUpdateManyWithWhereWithoutUserBookInput!]
  upsert: [ReadDateUpsertWithWhereUniqueWithoutUserBookInput!]
}

input ReadDateUpdateWithWhereUniqueWithoutUserBookInput {
  data: ReadDateUpdateWithoutUserBookInput!
  where: ReadDateWhereUniqueInput!
}

input ReadDateUpdateWithoutUserBookInput {
  active: Boolean
  finishedDate: Timestamp
  id: String
  readingProgress: ReadingProgressUpdateOneWithoutReadDateNestedInput
  startDate: Timestamp
}

input ReadDateUpsertWithWhereUniqueWithoutUserBookInput {
  create: ReadDateCreateWithoutUserBookInput!
  update: ReadDateUpdateWithoutUserBookInput!
  where: ReadDateWhereUniqueInput!
}

input ReadDateWhereInput {
  AND: [ReadDateWhereInput!]
  NOT: [ReadDateWhereInput!]
  OR: [ReadDateWhereInput!]
  active: BoolFilter
  finishedDate: DateTimeFilter
  id: StringFilter
  readingProgress: ReadingProgressScalarRelationFilter
  startDate: DateTimeFilter
  userBook: UserBookScalarRelationFilter
  userBookId: StringFilter
}

input ReadDateWhereUniqueInput {
  AND: [ReadDateWhereInput!]
  NOT: [ReadDateWhereInput!]
  OR: [ReadDateWhereInput!]
  active: BoolFilter
  finishedDate: DateTimeFilter
  id: String
  readingProgress: ReadingProgressScalarRelationFilter
  startDate: DateTimeFilter
  userBook: UserBookScalarRelationFilter
  userBookId: StringFilter
}

type ReadingProgress {
  capacity: Int!
  createdAt: Timestamp!
  id: ID!
  progress: Int!
  readDate: ReadDate!
  readDateId: String!
  type: PROGRESS_TYPE!
}

type ReadingProgressAvgAggregate {
  capacity: Float
  progress: Float
}

type ReadingProgressCountAggregate {
  _all: Int!
  capacity: Int!
  createdAt: Int!
  id: Int!
  progress: Int!
  readDateId: Int!
  type: Int!
}

input ReadingProgressCreateNestedOneWithoutReadDateInput {
  connect: ReadingProgressWhereUniqueInput
  connectOrCreate: ReadingProgressCreateOrConnectWithoutReadDateInput
  create: ReadingProgressCreateWithoutReadDateInput
}

input ReadingProgressCreateOrConnectWithoutReadDateInput {
  create: ReadingProgressCreateWithoutReadDateInput!
  where: ReadingProgressWhereUniqueInput!
}

input ReadingProgressCreateWithoutReadDateInput {
  capacity: Int!
  createdAt: Timestamp
  id: String
  progress: Int!
  type: PROGRESS_TYPE!
}

type ReadingProgressMaxAggregate {
  capacity: Int
  createdAt: Timestamp
  id: String
  progress: Int
  readDateId: String
  type: PROGRESS_TYPE
}

type ReadingProgressMinAggregate {
  capacity: Int
  createdAt: Timestamp
  id: String
  progress: Int
  readDateId: String
  type: PROGRESS_TYPE
}

input ReadingProgressScalarRelationFilter {
  is: ReadingProgressWhereInput
  isNot: ReadingProgressWhereInput
}

type ReadingProgressSumAggregate {
  capacity: Int
  progress: Int
}

input ReadingProgressUpdateOneWithoutReadDateNestedInput {
  connect: ReadingProgressWhereUniqueInput
  connectOrCreate: ReadingProgressCreateOrConnectWithoutReadDateInput
  create: ReadingProgressCreateWithoutReadDateInput
  delete: ReadingProgressWhereInput
  disconnect: ReadingProgressWhereInput
  update: ReadingProgressUpdateToOneWithWhereWithoutReadDateInput
  upsert: ReadingProgressUpsertWithoutReadDateInput
}

input ReadingProgressUpdateToOneWithWhereWithoutReadDateInput {
  data: ReadingProgressUpdateWithoutReadDateInput!
  where: ReadingProgressWhereInput
}

input ReadingProgressUpdateWithoutReadDateInput {
  capacity: Int
  createdAt: Timestamp
  id: String
  progress: Int
  type: PROGRESS_TYPE
}

input ReadingProgressUpsertWithoutReadDateInput {
  create: ReadingProgressCreateWithoutReadDateInput!
  update: ReadingProgressUpdateWithoutReadDateInput!
  where: ReadingProgressWhereInput
}

input ReadingProgressWhereInput {
  AND: [ReadingProgressWhereInput!]
  NOT: [ReadingProgressWhereInput!]
  OR: [ReadingProgressWhereInput!]
  capacity: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  progress: IntFilter
  readDate: ReadDateScalarRelationFilter
  readDateId: StringFilter
  type: EnumPROGRESS_TYPEFilter
}

input ReadingProgressWhereUniqueInput {
  AND: [ReadingProgressWhereInput!]
  NOT: [ReadingProgressWhereInput!]
  OR: [ReadingProgressWhereInput!]
  capacity: IntFilter
  createdAt: DateTimeFilter
  id: String
  progress: IntFilter
  readDate: ReadDateScalarRelationFilter
  readDateId: String
  type: EnumPROGRESS_TYPEFilter
}

type RefreshResponse {
  accessToken: String!
  expiresIn: Float!
  refreshToken: String!
}

input RegisterInput {
  email: String!
  password: String!
  username: String!
}

input ResetPasswordInput {
  password: String!
  token: String!
}

enum SIZE {
  LARGE
  MEDIUM
  SMALL
}

enum SOURCE {
  AMAZON
  GOODREADS
  GOOGLE
  ISBN_10
  ISBN_13
  OPEN_LIBRARY
}

type Shelf {
  _count: ShelfCount!
  dateTime: String
  id: ID!
  name: String!
  slug: String!
  user: User
  userBooks: [UserBookShelves!]
  userId: String
}

type ShelfCount {
  userBooks: Int!
}

type ShelfCountAggregate {
  _all: Int!
  dateTime: Int!
  id: Int!
  name: Int!
  slug: Int!
  userId: Int!
}

input ShelfCreateInput {
  dateTime: String
  id: String
  name: String!
  slug: String!
  user: UserCreateNestedOneWithoutShelvesInput
  userBooks: UserBookShelvesCreateNestedManyWithoutShelfInput
}

input ShelfCreateManyUserInput {
  dateTime: String
  id: String
  name: String!
  slug: String!
}

input ShelfCreateManyUserInputEnvelope {
  data: [ShelfCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ShelfCreateNestedManyWithoutUserInput {
  connect: [ShelfWhereUniqueInput!]
  connectOrCreate: [ShelfCreateOrConnectWithoutUserInput!]
  create: [ShelfCreateWithoutUserInput!]
  createMany: ShelfCreateManyUserInputEnvelope
}

input ShelfCreateNestedOneWithoutUserBooksInput {
  connect: ShelfWhereUniqueInput
  connectOrCreate: ShelfCreateOrConnectWithoutUserBooksInput
  create: ShelfCreateWithoutUserBooksInput
}

input ShelfCreateOrConnectWithoutUserBooksInput {
  create: ShelfCreateWithoutUserBooksInput!
  where: ShelfWhereUniqueInput!
}

input ShelfCreateOrConnectWithoutUserInput {
  create: ShelfCreateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfCreateWithoutUserBooksInput {
  dateTime: String
  id: String
  name: String!
  slug: String!
  user: UserCreateNestedOneWithoutShelvesInput
}

input ShelfCreateWithoutUserInput {
  dateTime: String
  id: String
  name: String!
  slug: String!
  userBooks: UserBookShelvesCreateNestedManyWithoutShelfInput
}

input ShelfIdentifierCompoundUniqueInput {
  name: String!
  userId: String!
}

input ShelfListRelationFilter {
  every: ShelfWhereInput
  none: ShelfWhereInput
  some: ShelfWhereInput
}

type ShelfMaxAggregate {
  dateTime: String
  id: String
  name: String
  slug: String
  userId: String
}

type ShelfMinAggregate {
  dateTime: String
  id: String
  name: String
  slug: String
  userId: String
}

input ShelfOrderByRelationAggregateInput {
  _count: SortOrder
}

input ShelfScalarRelationFilter {
  is: ShelfWhereInput
  isNot: ShelfWhereInput
}

input ShelfScalarWhereInput {
  AND: [ShelfScalarWhereInput!]
  NOT: [ShelfScalarWhereInput!]
  OR: [ShelfScalarWhereInput!]
  dateTime: StringFilter
  id: StringFilter
  name: StringFilter
  slug: StringFilter
  userId: StringFilter
}

input ShelfUpdateInput {
  dateTime: String
  id: String
  name: String
  slug: String
  user: UserUpdateOneWithoutShelvesNestedInput
  userBooks: UserBookShelvesUpdateManyWithoutShelfNestedInput
}

input ShelfUpdateManyMutationInput {
  dateTime: String
  id: String
  name: String
  slug: String
}

input ShelfUpdateManyWithWhereWithoutUserInput {
  data: ShelfUpdateManyMutationInput!
  where: ShelfScalarWhereInput!
}

input ShelfUpdateManyWithoutUserNestedInput {
  connect: [ShelfWhereUniqueInput!]
  connectOrCreate: [ShelfCreateOrConnectWithoutUserInput!]
  create: [ShelfCreateWithoutUserInput!]
  createMany: ShelfCreateManyUserInputEnvelope
  delete: [ShelfWhereUniqueInput!]
  deleteMany: [ShelfScalarWhereInput!]
  disconnect: [ShelfWhereUniqueInput!]
  set: [ShelfWhereUniqueInput!]
  update: [ShelfUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ShelfUpdateManyWithWhereWithoutUserInput!]
  upsert: [ShelfUpsertWithWhereUniqueWithoutUserInput!]
}

input ShelfUpdateOneRequiredWithoutUserBooksNestedInput {
  connect: ShelfWhereUniqueInput
  connectOrCreate: ShelfCreateOrConnectWithoutUserBooksInput
  create: ShelfCreateWithoutUserBooksInput
  update: ShelfUpdateToOneWithWhereWithoutUserBooksInput
  upsert: ShelfUpsertWithoutUserBooksInput
}

input ShelfUpdateToOneWithWhereWithoutUserBooksInput {
  data: ShelfUpdateWithoutUserBooksInput!
  where: ShelfWhereInput
}

input ShelfUpdateWithWhereUniqueWithoutUserInput {
  data: ShelfUpdateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfUpdateWithoutUserBooksInput {
  dateTime: String
  id: String
  name: String
  slug: String
  user: UserUpdateOneWithoutShelvesNestedInput
}

input ShelfUpdateWithoutUserInput {
  dateTime: String
  id: String
  name: String
  slug: String
  userBooks: UserBookShelvesUpdateManyWithoutShelfNestedInput
}

input ShelfUpsertWithWhereUniqueWithoutUserInput {
  create: ShelfCreateWithoutUserInput!
  update: ShelfUpdateWithoutUserInput!
  where: ShelfWhereUniqueInput!
}

input ShelfUpsertWithoutUserBooksInput {
  create: ShelfCreateWithoutUserBooksInput!
  update: ShelfUpdateWithoutUserBooksInput!
  where: ShelfWhereInput
}

input ShelfWhereInput {
  AND: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  dateTime: StringFilter
  id: StringFilter
  name: StringFilter
  slug: StringFilter
  user: UserScalarRelationFilter
  userBooks: UserBookShelvesListRelationFilter
  userId: StringFilter
}

input ShelfWhereUniqueInput {
  AND: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  dateTime: StringFilter
  id: String
  identifier: ShelfIdentifierCompoundUniqueInput
  name: StringFilter
  slug: String
  user: UserScalarRelationFilter
  userBooks: UserBookShelvesListRelationFilter
  userId: StringFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: StringFilter
  notIn: [String!]
  startsWith: String
}

input StringListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

"""
`Date` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

input UpdateEmailInput {
  code: String!
  email: String!
  token: String!
}

input UpdatePasswordInput {
  newPassword: String
  password: String
}

input UpdateUserInput {
  avatarImage: String
  bio: String
  email: String
  location: String
  name: String
  username: String
}

type User {
  _count: UserCount!
  avatarImage: String
  bio: String
  createdAt: Timestamp!
  email: String!
  emailVerified: Timestamp
  id: ID!
  location: String
  name: String
  passwordUpdatedAt: Timestamp!
  shelves: [Shelf!]
  updatedAt: Timestamp!
  userBooks: [UserBook!]
  username: String
}

type UserBook {
  _count: UserBookCount!
  book: Book!
  bookId: String!
  createdAt: Timestamp!
  dateAdded: Timestamp!
  id: ID!
  order: Int!
  rating: Float
  readDates: [ReadDate!]
  shelves: [UserBookShelves!]
  status: READING_STATUS!
  updatedAt: Timestamp!
  user: User!
  userId: String!
}

type UserBookAvgAggregate {
  order: Float
  rating: Float
}

type UserBookCount {
  readDates: Int!
  shelves: Int!
}

type UserBookCountAggregate {
  _all: Int!
  bookId: Int!
  createdAt: Int!
  dateAdded: Int!
  id: Int!
  order: Int!
  rating: Int!
  status: Int!
  updatedAt: Int!
  userId: Int!
}

input UserBookCreateManyUserInput {
  bookId: String!
  createdAt: Timestamp
  dateAdded: Timestamp!
  id: String
  order: Int
  rating: Float
  status: READING_STATUS!
  updatedAt: Timestamp
}

input UserBookCreateManyUserInputEnvelope {
  data: [UserBookCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserBookCreateNestedManyWithoutUserInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
  createMany: UserBookCreateManyUserInputEnvelope
}

input UserBookCreateNestedOneWithoutBookInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutBookInput
  create: UserBookCreateWithoutBookInput
}

input UserBookCreateNestedOneWithoutShelvesInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutShelvesInput
  create: UserBookCreateWithoutShelvesInput
}

input UserBookCreateOrConnectWithoutBookInput {
  create: UserBookCreateWithoutBookInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutShelvesInput {
  create: UserBookCreateWithoutShelvesInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateOrConnectWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookCreateWithoutBookInput {
  createdAt: Timestamp
  dateAdded: Timestamp!
  id: String
  order: Int
  rating: Float
  readDates: ReadDateCreateNestedManyWithoutUserBookInput
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: READING_STATUS!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutUserBooksInput!
}

input UserBookCreateWithoutShelvesInput {
  book: BookCreateNestedOneWithoutUserBookInput!
  createdAt: Timestamp
  dateAdded: Timestamp!
  id: String
  order: Int
  rating: Float
  readDates: ReadDateCreateNestedManyWithoutUserBookInput
  status: READING_STATUS!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutUserBooksInput!
}

input UserBookCreateWithoutUserInput {
  book: BookCreateNestedOneWithoutUserBookInput!
  createdAt: Timestamp
  dateAdded: Timestamp!
  id: String
  order: Int
  rating: Float
  readDates: ReadDateCreateNestedManyWithoutUserBookInput
  shelves: UserBookShelvesCreateNestedManyWithoutUserBookInput
  status: READING_STATUS!
  updatedAt: Timestamp
}

input UserBookIdentifierCompoundUniqueInput {
  bookId: String!
  userId: String!
}

input UserBookListRelationFilter {
  every: UserBookWhereInput
  none: UserBookWhereInput
  some: UserBookWhereInput
}

type UserBookMaxAggregate {
  bookId: String
  createdAt: Timestamp
  dateAdded: Timestamp
  id: String
  order: Int
  rating: Float
  status: READING_STATUS
  updatedAt: Timestamp
  userId: String
}

type UserBookMinAggregate {
  bookId: String
  createdAt: Timestamp
  dateAdded: Timestamp
  id: String
  order: Int
  rating: Float
  status: READING_STATUS
  updatedAt: Timestamp
  userId: String
}

input UserBookOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserBookOrderByWithRelationInput {
  book: BookOrderByWithRelationInput
  bookId: SortOrder
  createdAt: SortOrder
  dateAdded: SortOrder
  id: SortOrder
  order: SortOrder
  rating: SortOrderInput
  readDates: ReadDateOrderByRelationAggregateInput
  shelves: UserBookShelvesOrderByRelationAggregateInput
  status: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input UserBookScalarRelationFilter {
  is: UserBookWhereInput
  isNot: UserBookWhereInput
}

input UserBookScalarWhereInput {
  AND: [UserBookScalarWhereInput!]
  NOT: [UserBookScalarWhereInput!]
  OR: [UserBookScalarWhereInput!]
  bookId: StringFilter
  createdAt: DateTimeFilter
  dateAdded: DateTimeFilter
  id: StringFilter
  order: IntFilter
  rating: FloatFilter
  status: EnumREADING_STATUSFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

type UserBookShelves {
  shelf: Shelf!
  shelfId: String!
  userBook: UserBook!
  userBookId: String!
}

type UserBookShelvesCountAggregate {
  _all: Int!
  shelfId: Int!
  userBookId: Int!
}

input UserBookShelvesCreateManyShelfInput {
  userBookId: String!
}

input UserBookShelvesCreateManyShelfInputEnvelope {
  data: [UserBookShelvesCreateManyShelfInput!]!
  skipDuplicates: Boolean
}

input UserBookShelvesCreateManyUserBookInput {
  shelfId: String!
}

input UserBookShelvesCreateManyUserBookInputEnvelope {
  data: [UserBookShelvesCreateManyUserBookInput!]!
  skipDuplicates: Boolean
}

input UserBookShelvesCreateNestedManyWithoutShelfInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutShelfInput!]
  create: [UserBookShelvesCreateWithoutShelfInput!]
  createMany: UserBookShelvesCreateManyShelfInputEnvelope
}

input UserBookShelvesCreateNestedManyWithoutUserBookInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutUserBookInput!]
  create: [UserBookShelvesCreateWithoutUserBookInput!]
  createMany: UserBookShelvesCreateManyUserBookInputEnvelope
}

input UserBookShelvesCreateOrConnectWithoutShelfInput {
  create: UserBookShelvesCreateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesCreateOrConnectWithoutUserBookInput {
  create: UserBookShelvesCreateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesCreateWithoutShelfInput {
  userBook: UserBookCreateNestedOneWithoutShelvesInput!
}

input UserBookShelvesCreateWithoutUserBookInput {
  shelf: ShelfCreateNestedOneWithoutUserBooksInput!
}

input UserBookShelvesListRelationFilter {
  every: UserBookShelvesWhereInput
  none: UserBookShelvesWhereInput
  some: UserBookShelvesWhereInput
}

type UserBookShelvesMaxAggregate {
  shelfId: String
  userBookId: String
}

type UserBookShelvesMinAggregate {
  shelfId: String
  userBookId: String
}

input UserBookShelvesOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserBookShelvesScalarWhereInput {
  AND: [UserBookShelvesScalarWhereInput!]
  NOT: [UserBookShelvesScalarWhereInput!]
  OR: [UserBookShelvesScalarWhereInput!]
  shelfId: StringFilter
  userBookId: StringFilter
}

input UserBookShelvesUncheckedUpdateManyWithoutShelfInput {
  userBookId: String
}

input UserBookShelvesUncheckedUpdateManyWithoutUserBookInput {
  shelfId: String
}

input UserBookShelvesUpdateManyWithWhereWithoutShelfInput {
  data: UserBookShelvesUncheckedUpdateManyWithoutShelfInput!
  where: UserBookShelvesScalarWhereInput!
}

input UserBookShelvesUpdateManyWithWhereWithoutUserBookInput {
  data: UserBookShelvesUncheckedUpdateManyWithoutUserBookInput!
  where: UserBookShelvesScalarWhereInput!
}

input UserBookShelvesUpdateManyWithoutShelfNestedInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutShelfInput!]
  create: [UserBookShelvesCreateWithoutShelfInput!]
  createMany: UserBookShelvesCreateManyShelfInputEnvelope
  delete: [UserBookShelvesWhereUniqueInput!]
  deleteMany: [UserBookShelvesScalarWhereInput!]
  disconnect: [UserBookShelvesWhereUniqueInput!]
  set: [UserBookShelvesWhereUniqueInput!]
  update: [UserBookShelvesUpdateWithWhereUniqueWithoutShelfInput!]
  updateMany: [UserBookShelvesUpdateManyWithWhereWithoutShelfInput!]
  upsert: [UserBookShelvesUpsertWithWhereUniqueWithoutShelfInput!]
}

input UserBookShelvesUpdateManyWithoutUserBookNestedInput {
  connect: [UserBookShelvesWhereUniqueInput!]
  connectOrCreate: [UserBookShelvesCreateOrConnectWithoutUserBookInput!]
  create: [UserBookShelvesCreateWithoutUserBookInput!]
  createMany: UserBookShelvesCreateManyUserBookInputEnvelope
  delete: [UserBookShelvesWhereUniqueInput!]
  deleteMany: [UserBookShelvesScalarWhereInput!]
  disconnect: [UserBookShelvesWhereUniqueInput!]
  set: [UserBookShelvesWhereUniqueInput!]
  update: [UserBookShelvesUpdateWithWhereUniqueWithoutUserBookInput!]
  updateMany: [UserBookShelvesUpdateManyWithWhereWithoutUserBookInput!]
  upsert: [UserBookShelvesUpsertWithWhereUniqueWithoutUserBookInput!]
}

input UserBookShelvesUpdateWithWhereUniqueWithoutShelfInput {
  data: UserBookShelvesUpdateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpdateWithWhereUniqueWithoutUserBookInput {
  data: UserBookShelvesUpdateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpdateWithoutShelfInput {
  userBook: UserBookUpdateOneRequiredWithoutShelvesNestedInput
}

input UserBookShelvesUpdateWithoutUserBookInput {
  shelf: ShelfUpdateOneRequiredWithoutUserBooksNestedInput
}

input UserBookShelvesUpsertWithWhereUniqueWithoutShelfInput {
  create: UserBookShelvesCreateWithoutShelfInput!
  update: UserBookShelvesUpdateWithoutShelfInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUpsertWithWhereUniqueWithoutUserBookInput {
  create: UserBookShelvesCreateWithoutUserBookInput!
  update: UserBookShelvesUpdateWithoutUserBookInput!
  where: UserBookShelvesWhereUniqueInput!
}

input UserBookShelvesUserBookIdShelfIdCompoundUniqueInput {
  shelfId: String!
  userBookId: String!
}

input UserBookShelvesWhereInput {
  AND: [UserBookShelvesWhereInput!]
  NOT: [UserBookShelvesWhereInput!]
  OR: [UserBookShelvesWhereInput!]
  shelf: ShelfScalarRelationFilter
  shelfId: StringFilter
  userBook: UserBookScalarRelationFilter
  userBookId: StringFilter
}

input UserBookShelvesWhereUniqueInput {
  AND: [UserBookShelvesWhereInput!]
  NOT: [UserBookShelvesWhereInput!]
  OR: [UserBookShelvesWhereInput!]
  shelf: ShelfScalarRelationFilter
  shelfId: StringFilter
  userBook: UserBookScalarRelationFilter
  userBookId: StringFilter
  userBookId_shelfId: UserBookShelvesUserBookIdShelfIdCompoundUniqueInput
}

type UserBookSumAggregate {
  order: Int
  rating: Float
}

input UserBookUpdateInput {
  rating: Float
  shelves: [String!]
  status: READING_STATUS
}

input UserBookUpdateManyMutationInput {
  createdAt: Timestamp
  dateAdded: Timestamp
  id: String
  order: Int
  rating: Float
  status: READING_STATUS
  updatedAt: Timestamp
}

input UserBookUpdateManyWithWhereWithoutUserInput {
  data: UserBookUpdateManyMutationInput!
  where: UserBookScalarWhereInput!
}

input UserBookUpdateManyWithoutUserNestedInput {
  connect: [UserBookWhereUniqueInput!]
  connectOrCreate: [UserBookCreateOrConnectWithoutUserInput!]
  create: [UserBookCreateWithoutUserInput!]
  createMany: UserBookCreateManyUserInputEnvelope
  delete: [UserBookWhereUniqueInput!]
  deleteMany: [UserBookScalarWhereInput!]
  disconnect: [UserBookWhereUniqueInput!]
  set: [UserBookWhereUniqueInput!]
  update: [UserBookUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserBookUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserBookUpsertWithWhereUniqueWithoutUserInput!]
}

input UserBookUpdateOneRequiredWithoutShelvesNestedInput {
  connect: UserBookWhereUniqueInput
  connectOrCreate: UserBookCreateOrConnectWithoutShelvesInput
  create: UserBookCreateWithoutShelvesInput
  update: UserBookUpdateToOneWithWhereWithoutShelvesInput
  upsert: UserBookUpsertWithoutShelvesInput
}

input UserBookUpdateToOneWithWhereWithoutShelvesInput {
  data: UserBookUpdateWithoutShelvesInput!
  where: UserBookWhereInput
}

input UserBookUpdateWithWhereUniqueWithoutUserInput {
  data: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpdateWithoutShelvesInput {
  book: BookUpdateOneRequiredWithoutUserBookNestedInput
  createdAt: Timestamp
  dateAdded: Timestamp
  id: String
  order: Int
  rating: Float
  readDates: ReadDateUpdateManyWithoutUserBookNestedInput
  status: READING_STATUS
  updatedAt: Timestamp
  user: UserUpdateOneRequiredWithoutUserBooksNestedInput
}

input UserBookUpdateWithoutUserInput {
  book: BookUpdateOneRequiredWithoutUserBookNestedInput
  createdAt: Timestamp
  dateAdded: Timestamp
  id: String
  order: Int
  rating: Float
  readDates: ReadDateUpdateManyWithoutUserBookNestedInput
  shelves: UserBookShelvesUpdateManyWithoutUserBookNestedInput
  status: READING_STATUS
  updatedAt: Timestamp
}

input UserBookUpsertWithWhereUniqueWithoutUserInput {
  create: UserBookCreateWithoutUserInput!
  update: UserBookUpdateWithoutUserInput!
  where: UserBookWhereUniqueInput!
}

input UserBookUpsertWithoutShelvesInput {
  create: UserBookCreateWithoutShelvesInput!
  update: UserBookUpdateWithoutShelvesInput!
  where: UserBookWhereInput
}

input UserBookWhereInput {
  AND: [UserBookWhereInput!]
  NOT: [UserBookWhereInput!]
  OR: [UserBookWhereInput!]
  book: BookScalarRelationFilter
  bookId: StringFilter
  createdAt: DateTimeFilter
  dateAdded: DateTimeFilter
  id: StringFilter
  order: IntFilter
  rating: FloatFilter
  readDates: ReadDateListRelationFilter
  shelves: UserBookShelvesListRelationFilter
  status: EnumREADING_STATUSFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input UserBookWhereUniqueInput {
  AND: [UserBookWhereInput!]
  NOT: [UserBookWhereInput!]
  OR: [UserBookWhereInput!]
  book: BookScalarRelationFilter
  bookId: String
  createdAt: DateTimeFilter
  dateAdded: DateTimeFilter
  id: String
  identifier: UserBookIdentifierCompoundUniqueInput
  order: IntFilter
  rating: FloatFilter
  readDates: ReadDateListRelationFilter
  shelves: UserBookShelvesListRelationFilter
  status: EnumREADING_STATUSFilter
  updatedAt: DateTimeFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type UserBooksResponse {
  hasMore: Boolean!
  totalBooks: Float!
  userBooks: [UserBook!]
}

type UserCount {
  shelves: Int!
  userBooks: Int!
}

type UserCountAggregate {
  _all: Int!
  avatarImage: Int!
  bio: Int!
  createdAt: Int!
  email: Int!
  emailVerified: Int!
  id: Int!
  location: Int!
  name: Int!
  passwordUpdatedAt: Int!
  updatedAt: Int!
  username: Int!
}

input UserCreateNestedOneWithoutShelvesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutShelvesInput
  create: UserCreateWithoutShelvesInput
}

input UserCreateNestedOneWithoutUserBooksInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserBooksInput
  create: UserCreateWithoutUserBooksInput
}

input UserCreateOrConnectWithoutShelvesInput {
  create: UserCreateWithoutShelvesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutUserBooksInput {
  create: UserCreateWithoutUserBooksInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutShelvesInput {
  avatarImage: String
  bio: String
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  location: String
  name: String
  passwordUpdatedAt: Timestamp
  updatedAt: Timestamp
  userBooks: UserBookCreateNestedManyWithoutUserInput
  username: String
}

input UserCreateWithoutUserBooksInput {
  avatarImage: String
  bio: String
  createdAt: Timestamp
  email: String!
  emailVerified: Timestamp
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  location: String
  name: String
  passwordUpdatedAt: Timestamp
  shelves: ShelfCreateNestedManyWithoutUserInput
  updatedAt: Timestamp
  username: String
}

type UserMaxAggregate {
  avatarImage: String
  bio: String
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  id: String
  location: String
  name: String
  passwordUpdatedAt: Timestamp
  updatedAt: Timestamp
  username: String
}

type UserMinAggregate {
  avatarImage: String
  bio: String
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  id: String
  location: String
  name: String
  passwordUpdatedAt: Timestamp
  updatedAt: Timestamp
  username: String
}

input UserOrderByWithRelationInput {
  avatarImage: SortOrderInput
  bio: SortOrderInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrderInput
  hashedPassword: SortOrderInput
  hashedRefreshToken: SortOrderInput
  id: SortOrder
  location: SortOrderInput
  name: SortOrderInput
  passwordUpdatedAt: SortOrder
  shelves: ShelfOrderByRelationAggregateInput
  updatedAt: SortOrder
  userBooks: UserBookOrderByRelationAggregateInput
  username: SortOrderInput
}

input UserScalarRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserUpdateOneRequiredWithoutUserBooksNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserBooksInput
  create: UserCreateWithoutUserBooksInput
  update: UserUpdateToOneWithWhereWithoutUserBooksInput
  upsert: UserUpsertWithoutUserBooksInput
}

input UserUpdateOneWithoutShelvesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutShelvesInput
  create: UserCreateWithoutShelvesInput
  delete: UserWhereInput
  disconnect: UserWhereInput
  update: UserUpdateToOneWithWhereWithoutShelvesInput
  upsert: UserUpsertWithoutShelvesInput
}

input UserUpdateToOneWithWhereWithoutShelvesInput {
  data: UserUpdateWithoutShelvesInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutUserBooksInput {
  data: UserUpdateWithoutUserBooksInput!
  where: UserWhereInput
}

input UserUpdateWithoutShelvesInput {
  avatarImage: String
  bio: String
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  location: String
  name: String
  passwordUpdatedAt: Timestamp
  updatedAt: Timestamp
  userBooks: UserBookUpdateManyWithoutUserNestedInput
  username: String
}

input UserUpdateWithoutUserBooksInput {
  avatarImage: String
  bio: String
  createdAt: Timestamp
  email: String
  emailVerified: Timestamp
  hashedPassword: String
  hashedRefreshToken: String
  id: String
  location: String
  name: String
  passwordUpdatedAt: Timestamp
  shelves: ShelfUpdateManyWithoutUserNestedInput
  updatedAt: Timestamp
  username: String
}

input UserUpsertWithoutShelvesInput {
  create: UserCreateWithoutShelvesInput!
  update: UserUpdateWithoutShelvesInput!
  where: UserWhereInput
}

input UserUpsertWithoutUserBooksInput {
  create: UserCreateWithoutUserBooksInput!
  update: UserUpdateWithoutUserBooksInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  avatarImage: StringFilter
  bio: StringFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeFilter
  hashedPassword: StringFilter
  hashedRefreshToken: StringFilter
  id: StringFilter
  location: StringFilter
  name: StringFilter
  passwordUpdatedAt: DateTimeFilter
  shelves: ShelfListRelationFilter
  updatedAt: DateTimeFilter
  userBooks: UserBookListRelationFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  avatarImage: StringFilter
  bio: StringFilter
  createdAt: DateTimeFilter
  email: String
  emailVerified: DateTimeFilter
  hashedPassword: StringFilter
  hashedRefreshToken: StringFilter
  id: String
  location: StringFilter
  name: StringFilter
  passwordUpdatedAt: DateTimeFilter
  shelves: ShelfListRelationFilter
  updatedAt: DateTimeFilter
  userBooks: UserBookListRelationFilter
  username: String
}

type VerificationTokenCountAggregate {
  _all: Int!
  email: Int!
  expires: Int!
  id: Int!
  token: Int!
}

type VerificationTokenMaxAggregate {
  email: String
  expires: Timestamp
  id: String
  token: String
}

type VerificationTokenMinAggregate {
  email: String
  expires: Timestamp
  id: String
  token: String
}